"use strict";(self.webpackChunkphysical_ai_humanoid_robotics_textbook=self.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[479],{1470:(e,n,i)=>{i.d(n,{A:()=>z});var r=i(6540),s=i(4164),a=i(7559),t=i(3104),l=i(6347),o=i(205),d=i(7485),c=i(1682),m=i(679);function h(e){var n,i;return null!=(n=null==(i=r.Children.toArray(e).filter(function(e){return"\n"!==e}).map(function(e){if(!e||(0,r.isValidElement)(e)&&((n=e.props)&&"object"==typeof n&&"value"in n))return e;var n;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))?void 0:i.filter(Boolean))?n:[]}function u(e){var n=e.values,i=e.children;return(0,r.useMemo)(function(){var e=null!=n?n:function(e){return h(e).map(function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes,default:n.default}})}(i);return function(e){var n=(0,c.XI)(e,function(e,n){return e.value===n.value});if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map(function(e){return e.value}).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e},[n,i])}function x(e){var n=e.value;return e.tabValues.some(function(e){return e.value===n})}function p(e){var n=e.queryString,i=void 0!==n&&n,s=e.groupId,a=(0,l.W6)(),t=function(e){var n=e.queryString,i=void 0!==n&&n,r=e.groupId;if("string"==typeof i)return i;if(!1===i)return null;if(!0===i&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=r?r:null}({queryString:i,groupId:s});return[(0,d.aZ)(t),(0,r.useCallback)(function(e){if(t){var n=new URLSearchParams(a.location.search);n.set(t,e),a.replace(Object.assign({},a.location,{search:n.toString()}))}},[t,a])]}function g(e){var n,i,s,a,t=e.defaultValue,l=e.queryString,d=void 0!==l&&l,c=e.groupId,h=u(e),g=(0,r.useState)(function(){return function(e){var n,i=e.defaultValue,r=e.tabValues;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(i){if(!x({value:i,tabValues:r}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+i+'" but none of its children has the corresponding value. Available values are: '+r.map(function(e){return e.value}).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return i}var s=null!=(n=r.find(function(e){return e.default}))?n:r[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:t,tabValues:h})}),j=g[0],f=g[1],b=p({queryString:d,groupId:c}),y=b[0],v=b[1],_=(n=function(e){return e?"docusaurus.tab."+e:null}({groupId:c}.groupId),i=(0,m.Dv)(n),s=i[0],a=i[1],[s,(0,r.useCallback)(function(e){n&&a.set(e)},[n,a])]),z=_[0],w=_[1],R=function(){var e=null!=y?y:z;return x({value:e,tabValues:h})?e:null}();return(0,o.A)(function(){R&&f(R)},[R]),{selectedValue:j,selectValue:(0,r.useCallback)(function(e){if(!x({value:e,tabValues:h}))throw new Error("Can't select invalid tab value="+e);f(e),v(e),w(e)},[v,w,h]),tabValues:h}}var j=i(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=i(4848);function y(e){var n=e.className,i=e.block,r=e.selectedValue,a=e.selectValue,l=e.tabValues,o=[],d=(0,t.a_)().blockElementScrollPositionUntilNextRender,c=function(e){var n=e.currentTarget,i=o.indexOf(n),s=l[i].value;s!==r&&(d(n),a(s))},m=function(e){var n,i=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":var r,s=o.indexOf(e.currentTarget)+1;i=null!=(r=o[s])?r:o[0];break;case"ArrowLeft":var a,t=o.indexOf(e.currentTarget)-1;i=null!=(a=o[t])?a:o[o.length-1]}null==(n=i)||n.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":i},n),children:l.map(function(e){var n=e.value,i=e.label,a=e.attributes;return(0,b.jsx)("li",Object.assign({role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:function(e){o.push(e)},onKeyDown:m,onClick:c},a,{className:(0,s.A)("tabs__item",f.tabItem,null==a?void 0:a.className,{"tabs__item--active":r===n}),children:null!=i?i:n}),n)})})}function v(e){var n=e.lazy,i=e.children,a=e.selectedValue,t=(Array.isArray(i)?i:[i]).filter(Boolean);if(n){var l=t.find(function(e){return e.props.value===a});return l?(0,r.cloneElement)(l,{className:(0,s.A)("margin-top--md",l.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:t.map(function(e,n){return(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a})})})}function _(e){var n=g(e);return(0,b.jsxs)("div",{className:(0,s.A)(a.G.tabs.container,"tabs-container",f.tabList),children:[(0,b.jsx)(y,Object.assign({},n,e)),(0,b.jsx)(v,Object.assign({},n,e))]})}function z(e){var n=(0,j.A)();return(0,b.jsx)(_,Object.assign({},e,{children:h(e.children)}),String(n))}},8149:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"chapters/ch4-sim","title":"Chapter 4: Digital Twin Simulation with Gazebo","description":"Master physics simulation, sensor modeling, and sim-to-real transfer for humanoid robotics using Gazebo and URDF.","source":"@site/docs/chapters/ch4-sim.mdx","sourceDirName":"chapters","slug":"/chapters/ch4-sim","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/chapters/ch4-sim","draft":false,"unlisted":false,"editUrl":"https://github.com/Danishhshahid/docs/chapters/ch4-sim.mdx","tags":[],"version":"current","frontMatter":{"id":"ch4-sim","title":"Chapter 4: Digital Twin Simulation with Gazebo","sidebar_label":"Ch4: Simulation","description":"Master physics simulation, sensor modeling, and sim-to-real transfer for humanoid robotics using Gazebo and URDF.","keywords":["gazebo","urdf","simulation","digital twin","sim-to-real","physics engine","sensor simulation","domain randomization"],"image":"/img/ch4-sim-hero.png"},"sidebar":"tutorialSidebar","previous":{"title":"Ch3: ROS 2 Fundamentals","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/chapters/ch3-ros2"},"next":{"title":"Ch5: VLA Systems","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/chapters/ch5-vla"}}');var s=i(4848),a=i(8453),t=i(1470),l=i(9365);const o={id:"ch4-sim",title:"Chapter 4: Digital Twin Simulation with Gazebo",sidebar_label:"Ch4: Simulation",description:"Master physics simulation, sensor modeling, and sim-to-real transfer for humanoid robotics using Gazebo and URDF.",keywords:["gazebo","urdf","simulation","digital twin","sim-to-real","physics engine","sensor simulation","domain randomization"],image:"/img/ch4-sim-hero.png"},d=void 0,c={},m=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"4.1 What is a Digital Twin?",id:"41-what-is-a-digital-twin",level:2},{value:"Definition and Purpose",id:"definition-and-purpose",level:3},{value:"The Sim-to-Real Gap",id:"the-sim-to-real-gap",level:3},{value:"4.2 URDF Robot Models",id:"42-urdf-robot-models",level:2},{value:"URDF Overview",id:"urdf-overview",level:3},{value:"URDF Structure",id:"urdf-structure",level:3},{value:"Example: 2-DOF Arm URDF",id:"example-2-dof-arm-urdf",level:3},{value:"4.3 Gazebo Simulation Environment",id:"43-gazebo-simulation-environment",level:2},{value:"What is Gazebo?",id:"what-is-gazebo",level:3},{value:"Setting Up Gazebo",id:"setting-up-gazebo",level:3},{value:"Gazebo World File (SDF Format)",id:"gazebo-world-file-sdf-format",level:3},{value:"4.4 Sensor Simulation in Gazebo",id:"44-sensor-simulation-in-gazebo",level:2},{value:"Overview",id:"overview",level:3},{value:"Simulating an IMU Sensor",id:"simulating-an-imu-sensor",level:3},{value:"Simulating a Camera",id:"simulating-a-camera",level:3},{value:"4.5 Sim-to-Real Transfer via Domain Randomization",id:"45-sim-to-real-transfer-via-domain-randomization",level:2},{value:"The Reality Gap Problem",id:"the-reality-gap-problem",level:3},{value:"Implementation: Randomize Physics Parameters",id:"implementation-randomize-physics-parameters",level:3},{value:"Evaluating Sim-to-Real Success",id:"evaluating-sim-to-real-success",level:3},{value:"4.6 Embodiment Challenge: Sim-to-Real Grasping",id:"46-embodiment-challenge-sim-to-real-grasping",level:2},{value:"4.7 References",id:"47-references",level:2},{value:"4.8 RAG Integration Hooks",id:"48-rag-integration-hooks",level:2},{value:"Chapter Summary",id:"chapter-summary",level:2}];function h(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Describe digital twin architecture"})," and its role in reducing real-world testing risk"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Write URDF models"})," to represent robot structure, joints, and physics properties"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configure Gazebo simulators"})," with physics engines, sensors, and environmental factors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement sensor simulation"})," (camera, IMU, force/torque) within Gazebo"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Apply domain randomization techniques"})," to bridge the sim-to-real gap"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Evaluate sim-to-real transfer success"})," using quantitative metrics"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Key Concept",type:"info",children:(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"digital twin"})," is a physics-accurate virtual replica of a robot that enables safe, fast iteration before deploying to hardware. Simulation accelerates learning-based control development by 10-100\xd7 versus real-world training alone."]})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"41-what-is-a-digital-twin",children:"4.1 What is a Digital Twin?"}),"\n",(0,s.jsx)(n.h3,{id:"definition-and-purpose",children:"Definition and Purpose"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"digital twin"})," is a computationally faithful model of a physical robot that replicates its kinematics, dynamics, sensors, and environment in a virtual world. The digital twin serves three purposes:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rapid prototyping"}),": Test control algorithms without hardware risk or cost"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Learning-based control"}),": Train neural network policies with infinite synthetic data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scenario testing"}),": Simulate rare events (collision, failure modes, edge cases)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For humanoid robotics, digital twins are critical because real robots are expensive (~$100k\u2013$500k) and real-world training is slow. Simulation enables ",(0,s.jsx)(n.strong,{children:"sim-to-real transfer"}),": train a policy in simulation, deploy to the real robot, and expect ~70\u201380% performance retention."]}),"\n",(0,s.jsx)(n.h3,{id:"the-sim-to-real-gap",children:"The Sim-to-Real Gap"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"reality gap"})," is the performance drop when a policy trained entirely in simulation is deployed to real hardware:"]}),"\n",(0,s.jsx)(n.p,{children:"Transfer Success Rate = (Real-World Performance / Simulated Performance) \xd7 100%"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Typical results (2024\u20132025):"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Grasping tasks: 71\u201385% success (sim-to-real)"}),"\n",(0,s.jsx)(n.li,{children:"Locomotion (walking): 80\u201392% success"}),"\n",(0,s.jsx)(n.li,{children:"Manipulation (reaching): 65\u201378% success"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Causes of the reality gap:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics model errors"}),": Friction coefficients, inertia tensors, contact dynamics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor noise"}),": Real IMUs drift; cameras have latency and blur"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Actuation delay"}),": Motor controllers add 5\u201350 ms latency; simulation assumes instantaneous response"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unmodeled dynamics"}),": Cable routing, cable slack, motor backdrive friction"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Mitigation strategy:"})," Domain randomization\u2014vary simulation parameters randomly during training so the policy learns robust behaviors invariant to parameter uncertainty."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"42-urdf-robot-models",children:"4.2 URDF Robot Models"}),"\n",(0,s.jsx)(n.h3,{id:"urdf-overview",children:"URDF Overview"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"URDF"})," (Unified Robot Description Format) is an XML-based file format that describes a robot's kinematic chain, inertial properties, collision geometry, and visual representation. URDF files are the standard in ROS 2 and Gazebo."]}),"\n",(0,s.jsx)(n.h3,{id:"urdf-structure",children:"URDF Structure"}),"\n",(0,s.jsx)(n.p,{children:"A minimal URDF has this hierarchy:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'<robot name="NAME">\n  <link name="LINK_NAME">\n    \x3c!-- visual, inertial, collision properties --\x3e\n  </link>\n  <joint name="JOINT_NAME" type="TYPE">\n    \x3c!-- parent/child links, axis, limits --\x3e\n  </joint>\n</robot>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key elements:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Element"}),(0,s.jsx)(n.th,{children:"Purpose"}),(0,s.jsx)(n.th,{children:"Example"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<robot>"})}),(0,s.jsx)(n.td,{children:"Root container"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'<robot name="humanoid">'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<link>"})}),(0,s.jsx)(n.td,{children:"Rigid body (mass, geometry)"}),(0,s.jsx)(n.td,{children:"Base, arm, gripper"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<joint>"})}),(0,s.jsx)(n.td,{children:"Connection between links"}),(0,s.jsx)(n.td,{children:"Revolute (1-DOF), prismatic (sliding)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<inertial>"})}),(0,s.jsx)(n.td,{children:"Mass and inertia tensor"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'<mass value="2.5"/>'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<collision>"})}),(0,s.jsx)(n.td,{children:"Physics-checked shape"}),(0,s.jsx)(n.td,{children:"Simplify for speed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<visual>"})}),(0,s.jsx)(n.td,{children:"Display mesh for visualization"}),(0,s.jsx)(n.td,{children:"High-poly mesh"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<gazebo>"})}),(0,s.jsx)(n.td,{children:"Gazebo-specific properties"}),(0,s.jsx)(n.td,{children:"Material, friction coefficients"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"example-2-dof-arm-urdf",children:"Example: 2-DOF Arm URDF"}),"\n",(0,s.jsx)(n.p,{children:"Let's build a simple 2-DOF planar arm (shoulder + elbow):"}),"\n",(0,s.jsxs)(t.A,{children:[(0,s.jsx)(l.A,{value:"urdf",label:"URDF File (two_link_arm.urdf)",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="two_link_arm">\n\n  \x3c!-- Define the base link (fixed to world) --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n    <collision>\n      <geometry>\n        <box size="0.1 0.1 0.1"/>\n      </geometry>\n    </collision>\n    <visual>\n      <geometry>\n        <box size="0.1 0.1 0.1"/>\n      </geometry>\n      <material name="grey">\n        <color rgba="0.5 0.5 0.5 1.0"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- First link (shoulder to elbow) --\x3e\n  <link name="link_1">\n    <inertial>\n      <origin xyz="0.25 0 0"/>\n      <mass value="1.5"/>\n      \x3c!-- Inertia tensor for rod (L=0.5m, m=1.5kg) --\x3e\n      <inertia ixx="0.031" ixy="0.0" ixz="0.0" iyy="0.031" iyz="0.0" izz="0.001"/>\n    </inertial>\n    <collision>\n      <origin xyz="0.25 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.5"/>\n      </geometry>\n    </collision>\n    <visual>\n      <origin xyz="0.25 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.5"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0.0 0.0 1.0 1.0"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Second link (elbow to end-effector) --\x3e\n  <link name="link_2">\n    <inertial>\n      <origin xyz="0.25 0 0"/>\n      <mass value="1.0"/>\n      <inertia ixx="0.021" ixy="0.0" ixz="0.0" iyy="0.021" iyz="0.0" izz="0.001"/>\n    </inertial>\n    <collision>\n      <origin xyz="0.25 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.5"/>\n      </geometry>\n    </collision>\n    <visual>\n      <origin xyz="0.25 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.5"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1.0 0.0 0.0 1.0"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- End-effector (tool frame) --\x3e\n  <link name="end_effector">\n    <inertial>\n      <mass value="0.1"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n    </inertial>\n    <collision>\n      <geometry>\n        <sphere radius="0.02"/>\n      </geometry>\n    </collision>\n    <visual>\n      <geometry>\n        <sphere radius="0.02"/>\n      </geometry>\n      <material name="yellow">\n        <color rgba="1.0 1.0 0.0 1.0"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Shoulder joint (base_link to link_1) --\x3e\n  <joint name="shoulder_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="link_1"/>\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="10.0" velocity="2.0"/>\n    <dynamics damping="0.1" friction="0.05"/>\n  </joint>\n\n  \x3c!-- Elbow joint (link_1 to link_2) --\x3e\n  <joint name="elbow_joint" type="revolute">\n    <parent link="link_1"/>\n    <child link="link_2"/>\n    <origin xyz="0.5 0 0" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="8.0" velocity="2.0"/>\n    <dynamics damping="0.1" friction="0.05"/>\n  </joint>\n\n  \x3c!-- End-effector frame (link_2 to end_effector) --\x3e\n  <joint name="end_effector_joint" type="fixed">\n    <parent link="link_2"/>\n    <child link="end_effector"/>\n    <origin xyz="0.5 0 0" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- Gazebo plugins for simulation --\x3e\n  <gazebo>\n    <plugin filename="ignition-gazebo-joint-controller-system" name="ignition::gazebo::systems::JointController">\n    </plugin>\n  </gazebo>\n\n</robot>\n'})})}),(0,s.jsx)(l.A,{value:"usage",label:"Load and Visualize",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Launch Gazebo with the URDF model\ngazebo --verbose two_link_arm.urdf\n\n# OR load with ROS 2 using robot_state_publisher\nros2 launch my_bot view_robot.launch.py\n\n# Inspect URDF structure\nurdf_to_graphviz two_link_arm.urdf > two_link_arm.gv\ndot -Tpng two_link_arm.gv -o two_link_arm.png\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key URDF Parameters Explained:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Meaning"}),(0,s.jsx)(n.th,{children:"Tesla Optimus Arm"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<mass>"})}),(0,s.jsx)(n.td,{children:"Link mass (kg)"}),(0,s.jsx)(n.td,{children:"1.0\u20134.0 kg per segment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<inertia ixx, iyy, izz>"})}),(0,s.jsx)(n.td,{children:"Moment of inertia (kg\u22c5m\xb2)"}),(0,s.jsxs)(n.td,{children:[(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsxs)(n.msub,{children:[(0,s.jsx)(n.mi,{children:"I"}),(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"z"}),(0,s.jsx)(n.mi,{children:"z"})]})]}),(0,s.jsx)(n.mo,{children:"="}),(0,s.jsx)(n.mn,{children:"0.001"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"I_{zz} = 0.001"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,s.jsxs)(n.span,{className:"mord",children:[(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.07847em"},children:"I"}),(0,s.jsx)(n.span,{className:"msupsub",children:(0,s.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,s.jsxs)(n.span,{className:"vlist-r",children:[(0,s.jsx)(n.span,{className:"vlist",style:{height:"0.1514em"},children:(0,s.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"-0.0785em",marginRight:"0.05em"},children:[(0,s.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,s.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,s.jsx)(n.span,{className:"mord mtight",children:(0,s.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.04398em"},children:"zz"})})})]})}),(0,s.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,s.jsx)(n.span,{className:"vlist-r",children:(0,s.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,s.jsx)(n.span,{})})})]})})]}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"="}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,s.jsx)(n.span,{className:"mord",children:"0.001"})]})]})]})," for thin rod"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<limit lower, upper>"})}),(0,s.jsx)(n.td,{children:"Joint angle range (rad)"}),(0,s.jsx)(n.td,{children:"\xb1\u03c0/2 typical"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<effort>"})}),(0,s.jsx)(n.td,{children:"Max torque (N\u22c5m)"}),(0,s.jsx)(n.td,{children:"2.0\u20135.0 N\u22c5m"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<velocity>"})}),(0,s.jsx)(n.td,{children:"Max angular velocity (rad/s)"}),(0,s.jsx)(n.td,{children:"1.5\u20132.5 rad/s"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<damping>"})}),(0,s.jsx)(n.td,{children:"Friction coefficient"}),(0,s.jsx)(n.td,{children:"0.05\u20130.1"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"43-gazebo-simulation-environment",children:"4.3 Gazebo Simulation Environment"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-gazebo",children:"What is Gazebo?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Gazebo"})," (v11+, or Gazebo Ignition) is the de facto physics simulator for ROS 2 robots. It integrates:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics engines"}),": Bullet, ODE, DART (3D rigid-body dynamics)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor simulation"}),": Camera (ray-caster or GPU ray), IMU, lidar, F/T sensors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-time rendering"}),": Display robot state, camera feeds"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plugin system"}),": Load custom dynamics or control logic"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"setting-up-gazebo",children:"Setting Up Gazebo"}),"\n",(0,s.jsx)(n.p,{children:"Install Gazebo and ROS 2 integration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo apt update\nsudo apt install -y gazebo ros-humble-gazebo-ros\n\n# Verify installation\ngazebo --version\n"})}),"\n",(0,s.jsx)(n.h3,{id:"gazebo-world-file-sdf-format",children:"Gazebo World File (SDF Format)"}),"\n",(0,s.jsxs)(n.p,{children:["Gazebo uses ",(0,s.jsx)(n.strong,{children:"SDF"})," (Simulation Description Format) for worlds. A minimal world file:"]}),"\n",(0,s.jsxs)(t.A,{children:[(0,s.jsx)(l.A,{value:"world",label:"world.sdf",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.6">\n  <world name="humanoid_world">\n\n    \x3c!-- Physics engine configuration --\x3e\n    <physics name="default_physics" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <gravity>0 0 -9.81</gravity>\n    </physics>\n\n    \x3c!-- Scene (rendering) --\x3e\n    <scene>\n      <ambient>0.4 0.4 0.4 1.0</ambient>\n      <background>0.7 0.7 0.7 1.0</background>\n      <shadows>true</shadows>\n    </scene>\n\n    \x3c!-- Ground plane --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.6</mu>\n                <mu2>0.6</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <script>\n              <uri>file://media/materials/scripts/gazebo.material</uri>\n              <name>Gazebo/Grey</name>\n            <\/script>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.8 0.8 0.8 1</specular>\n      <direction>-0.5 0.1 -0.9</direction>\n    </light>\n\n    \x3c!-- Gazebo ROS 2 bridge plugin --\x3e\n    <plugin filename="ignition-gazebo-ros-init-system" name="ignition::gazebo::systems::RosInit">\n    </plugin>\n    <plugin filename="ignition-gazebo-ros-clock-system" name="ignition::gazebo::systems::RosClock">\n    </plugin>\n\n  </world>\n</sdf>\n'})})}),(0,s.jsx)(l.A,{value:"launch",label:"Launch File (launch.py)",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\n\ndef generate_launch_description():\n    gazebo_ros_dir = get_package_share_directory('gazebo_ros')\n\n    return LaunchDescription([\n        # Gazebo server\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource(\n                os.path.join(gazebo_ros_dir, 'launch', 'gazebo.launch.py'),\n            ),\n            launch_arguments=[('world', 'world.sdf')],\n        ),\n    ])\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Physics engine tuning (ODE):"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Effect"}),(0,s.jsx)(n.th,{children:"Value"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"max_step_size"})}),(0,s.jsx)(n.td,{children:"Simulation timestep (s)"}),(0,s.jsx)(n.td,{children:"0.001 (1 ms, accurate)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"real_time_factor"})}),(0,s.jsx)(n.td,{children:"Real-time ratio"}),(0,s.jsx)(n.td,{children:"1.0 (real-time), 0.5 (slower), 2.0 (faster)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"gravity"})}),(0,s.jsx)(n.td,{children:"Gravitational acceleration (m/s\xb2)"}),(0,s.jsx)(n.td,{children:"9.81 standard"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"mu"})," (friction)"]}),(0,s.jsx)(n.td,{children:"Coefficient of friction"}),(0,s.jsx)(n.td,{children:"0.6 (tile floor), 0.3 (ice)"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"44-sensor-simulation-in-gazebo",children:"4.4 Sensor Simulation in Gazebo"}),"\n",(0,s.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Real robots have noisy sensors. Gazebo simulates:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cameras"}),": RGB images, depth (lidar or stereo), semantic segmentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"IMU"}),": Accelerometer + gyroscope + Gaussian noise"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"F/T sensors"}),": Force and torque at joints"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Encoders"}),": Joint angle feedback with quantization"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"simulating-an-imu-sensor",children:"Simulating an IMU Sensor"}),"\n",(0,s.jsxs)(t.A,{children:[(0,s.jsx)(l.A,{value:"imu_urdf",label:"IMU in URDF",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add to link in URDF --\x3e\n<gazebo reference="imu_link">\n  <sensor name="imu_sensor" type="imu">\n    <always_on>true</always_on>\n    <update_rate>200</update_rate>  \x3c!-- 200 Hz --\x3e\n    <visualize>false</visualize>\n    <topic>imu</topic>\n    <plugin filename="ignition-gazebo-imu-system" name="ignition::gazebo::systems::Imu">\n      <accel_x_noise mean="0.0" stddev="0.02"/>\n      <accel_y_noise mean="0.0" stddev="0.02"/>\n      <accel_z_noise mean="0.0" stddev="0.02"/>\n      <gyro_x_noise mean="0.0" stddev="0.004"/>\n      <gyro_y_noise mean="0.0" stddev="0.004"/>\n      <gyro_z_noise mean="0.0" stddev="0.004"/>\n    </plugin>\n  </sensor>\n</gazebo>\n'})})}),(0,s.jsx)(l.A,{value:"imu_read",label:"Read IMU (rclpy)",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu\nimport numpy as np\n\nclass IMUSubscriber(Node):\n    def __init__(self):\n        super().__init__('imu_subscriber')\n        self.subscription = self.create_subscription(\n            Imu, '/imu', self.imu_callback, 10\n        )\n        self.linear_accel = np.array([0.0, 0.0, 0.0])\n        self.angular_vel = np.array([0.0, 0.0, 0.0])\n\n    def imu_callback(self, msg: Imu):\n        # Extract accelerometer data\n        self.linear_accel = np.array([\n            msg.linear_acceleration.x,\n            msg.linear_acceleration.y,\n            msg.linear_acceleration.z\n        ])\n\n        # Extract gyroscope data\n        self.angular_vel = np.array([\n            msg.angular_velocity.x,\n            msg.angular_velocity.y,\n            msg.angular_velocity.z\n        ])\n\n        self.get_logger().info(\n            f'Accel: {self.linear_accel}, '\n            f'Gyro: {self.angular_vel}'\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = IMUSubscriber()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"IMU Noise Model (Gaussian):"})}),"\n",(0,s.jsx)(n.p,{children:"\xe3 = a_true + N(0, \u03c3\xb2)"}),"\n",(0,s.jsx)(n.p,{children:"where \u03c3 = 0.02 m/s\xb2 (typical smartphone IMU noise)."}),"\n",(0,s.jsx)(n.h3,{id:"simulating-a-camera",children:"Simulating a Camera"}),"\n",(0,s.jsxs)(t.A,{children:[(0,s.jsx)(l.A,{value:"camera_urdf",label:"Camera in URDF",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="camera_link">\n  <sensor name="camera" type="camera">\n    <camera>\n      <horizontal_fov>1.047</horizontal_fov>  \x3c!-- 60 degrees --\x3e\n      <image>\n        <width>640</width>\n        <height>480</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.05</near>\n        <far>50.0</far>\n      </clip>\n      <noise>\n        <type>gaussian</type>\n        <mean>0.0</mean>\n        <stddev>0.007</stddev>  \x3c!-- Realistic camera noise --\x3e\n      </noise>\n    </camera>\n    <plugin filename="ignition-gazebo-camera-video-recorder-system"\n            name="ignition::gazebo::systems::VideoRecorder">\n      <video_name>camera_output</video_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})})}),(0,s.jsx)(l.A,{value:"camera_read",label:"Consume Camera Data",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import cv2\nimport numpy as np\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\n\nclass CameraSubscriber(Node):\n    def __init__(self):\n        super().__init__('camera_subscriber')\n        self.subscription = self.create_subscription(\n            Image, '/camera/image_raw', self.image_callback, 10\n        )\n        self.bridge = CvBridge()\n        self.latest_frame = None\n\n    def image_callback(self, msg: Image):\n        # Convert ROS 2 Image message to OpenCV format\n        self.latest_frame = self.bridge.imgmsg_to_cv2(msg, 'rgb8')\n\n        # Simple edge detection\n        gray = cv2.cvtColor(self.latest_frame, cv2.COLOR_RGB2GRAY)\n        edges = cv2.Canny(gray, 50, 150)\n\n        self.get_logger().debug(f'Frame shape: {self.latest_frame.shape}')\n\ndef main(args=None):\n    import rclpy\n    rclpy.init(args=args)\n    node = CameraSubscriber()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n"})})})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"45-sim-to-real-transfer-via-domain-randomization",children:"4.5 Sim-to-Real Transfer via Domain Randomization"}),"\n",(0,s.jsx)(n.h3,{id:"the-reality-gap-problem",children:"The Reality Gap Problem"}),"\n",(0,s.jsx)(n.p,{children:"Even with accurate physics, simulation differs from reality:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Friction coefficients"}),": Vary by surface type and wear"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mass uncertainty"}),": Actual mass \xb110% due to manufacturing tolerances"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Motor backlash"}),": Small delays in real motors not modeled in perfect simulation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor latency"}),": Real cameras lag 10\u201350 ms; simulation is instantaneous"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solution: Domain Randomization"})}),"\n",(0,s.jsxs)(n.p,{children:["Train policies with ",(0,s.jsx)(n.em,{children:"randomized"})," simulation parameters so the learned policy is robust to parameter uncertainty. At each training step, randomly sample:"]}),"\n",(0,s.jsx)(n.p,{children:"Friction ~ Uniform(0.3, 0.9)\nMass ~ Uniform(0.9m, 1.1m)\nMotor Delay ~ Uniform(0, 50 ms)"}),"\n",(0,s.jsx)(n.h3,{id:"implementation-randomize-physics-parameters",children:"Implementation: Randomize Physics Parameters"}),"\n",(0,s.jsxs)(t.A,{children:[(0,s.jsx)(l.A,{value:"randomize_urdf",label:"Python: Randomize URDF",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import xml.etree.ElementTree as ET\nimport random\nfrom typing import Dict\n\nclass URDFRandomizer:\n    """Randomize URDF parameters for domain randomization."""\n\n    def __init__(self, urdf_path: str):\n        self.tree = ET.parse(urdf_path)\n        self.root = self.tree.getroot()\n\n    def randomize_friction(self, min_mu: float = 0.3, max_mu: float = 0.9):\n        """Randomize friction coefficients for all links."""\n        for gazebo in self.root.findall(\'gazebo\'):\n            friction = gazebo.find(\'friction\')\n            if friction is not None:\n                ode = friction.find(\'ode\')\n                if ode is not None:\n                    mu = random.uniform(min_mu, max_mu)\n                    ode.set(\'mu\', str(mu))\n                    ode.set(\'mu2\', str(mu))\n\n    def randomize_mass(self, mass_scale_factor: tuple = (0.9, 1.1)):\n        """Randomize link masses."""\n        for link in self.root.findall(\'.//link\'):\n            inertial = link.find(\'inertial\')\n            if inertial is not None:\n                mass_elem = inertial.find(\'mass\')\n                if mass_elem is not None:\n                    original_mass = float(mass_elem.get(\'value\'))\n                    scale = random.uniform(*mass_scale_factor)\n                    new_mass = original_mass * scale\n                    mass_elem.set(\'value\', str(new_mass))\n\n    def randomize_motor_delay(self, max_delay_ms: float = 50.0):\n        """Simulate motor control delay by adding friction."""\n        for joint in self.root.findall(\'.//joint\'):\n            dynamics = joint.find(\'dynamics\')\n            if dynamics is not None:\n                # Increase damping to simulate motor lag\n                damping_scale = 1.0 + (max_delay_ms / 1000.0) * 0.5\n                old_damping = float(dynamics.get(\'damping\', 0.1))\n                new_damping = old_damping * damping_scale\n                dynamics.set(\'damping\', str(new_damping))\n\n    def save(self, output_path: str):\n        """Save randomized URDF to file."""\n        self.tree.write(output_path, encoding=\'utf-8\', xml_declaration=True)\n\n# Usage in training loop\ndef training_step():\n    """Randomize environment at each training step."""\n    randomizer = URDFRandomizer(\'two_link_arm.urdf\')\n    randomizer.randomize_friction()\n    randomizer.randomize_mass(mass_scale_factor=(0.9, 1.1))\n    randomizer.randomize_motor_delay(max_delay_ms=30)\n    randomizer.save(\'randomized_arm.urdf\')\n\n    # Launch Gazebo with randomized model\n    # ... train policy ...\n'})})}),(0,s.jsx)(l.A,{value:"randomize_sim",label:"Gazebo: Randomize World",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# randomize_world.sh - Randomize Gazebo world parameters\n\n# Generate random friction\nMU=$(python3 -c "import random; print(random.uniform(0.3, 0.9))")\n\n# Generate random mass multiplier\nMASS_SCALE=$(python3 -c "import random; print(random.uniform(0.9, 1.1))")\n\n# Generate random gravity (earth \xb1 0.5%)\nGRAVITY=$(python3 -c "import random; print(9.81 + random.uniform(-0.049, 0.049))")\n\n# Substitute into world.sdf template\nsed -e "s/<mu>.*<\\/mu>/<mu>${MU}<\\/mu>/g" \\\n    -e "s/<gravity>.*<\\/gravity>/<gravity>0 0 -${GRAVITY}<\\/gravity>/g" \\\n    world_template.sdf > world_randomized.sdf\n\n# Launch Gazebo\ngazebo world_randomized.sdf\n'})})})]}),"\n",(0,s.jsx)(n.h3,{id:"evaluating-sim-to-real-success",children:"Evaluating Sim-to-Real Success"}),"\n",(0,s.jsx)(n.p,{children:"After training in simulation with domain randomization, deploy to real robot and measure:"}),"\n",(0,s.jsx)(n.p,{children:"Success Rate = (# successful real-world trials) / (# total real-world trials) \xd7 100%"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Current SOTA (2024\u20132025):"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Task"}),(0,s.jsx)(n.th,{children:"Sim Success"}),(0,s.jsx)(n.th,{children:"Real Success"}),(0,s.jsx)(n.th,{children:"Transfer Rate"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Grasping (6-DoF arm)"}),(0,s.jsx)(n.td,{children:"95%"}),(0,s.jsx)(n.td,{children:"75%"}),(0,s.jsx)(n.td,{children:"79%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Object pushing"}),(0,s.jsx)(n.td,{children:"92%"}),(0,s.jsx)(n.td,{children:"74%"}),(0,s.jsx)(n.td,{children:"80%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Bin picking"}),(0,s.jsx)(n.td,{children:"88%"}),(0,s.jsx)(n.td,{children:"62%"}),(0,s.jsx)(n.td,{children:"71%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Humanoid walking"}),(0,s.jsx)(n.td,{children:"99%"}),(0,s.jsx)(n.td,{children:"87%"}),(0,s.jsx)(n.td,{children:"88%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Humanoid running"}),(0,s.jsx)(n.td,{children:"85%"}),(0,s.jsx)(n.td,{children:"71%"}),(0,s.jsx)(n.td,{children:"84%"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Factors improving transfer:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Higher simulation fidelity (physics solver accuracy)"}),"\n",(0,s.jsx)(n.li,{children:"Wider domain randomization ranges"}),"\n",(0,s.jsx)(n.li,{children:"Real-world pretraining data (visual domain adaptation)"}),"\n",(0,s.jsx)(n.li,{children:"Reduced action/observation delays"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"46-embodiment-challenge-sim-to-real-grasping",children:"4.6 Embodiment Challenge: Sim-to-Real Grasping"}),"\n",(0,s.jsxs)(n.admonition,{title:"Challenge: Close the Reality Gap",type:"danger",children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scenario:"})," You have a trained grasping policy from simulation (95% success). Deploy it to a real 6-DOF arm with parallel gripper. Initial real-world success: 58%."]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Your Task:"})}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Identify gaps"})," (30 min):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Record 10 real-world failures (video + sensor logs)"}),"\n",(0,s.jsx)(n.li,{children:"Compare real joint positions vs. simulated expected positions"}),"\n",(0,s.jsx)(n.li,{children:"Measure actual friction (push object; measure acceleration vs. applied force)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Randomize simulation"})," (45 min):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Create randomized friction range: [0.2, 1.2] (uniform distribution)"}),"\n",(0,s.jsx)(n.li,{children:"Add joint backlash: \xb12\xb0 per joint"}),"\n",(0,s.jsx)(n.li,{children:"Add sensor latency: 20\u201340 ms Gaussian"}),"\n",(0,s.jsx)(n.li,{children:"Retrain policy for 100k steps with randomization"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Deploy and measure"})," (20 min):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Test new policy on 50 real grasps"}),"\n",(0,s.jsx)(n.li,{children:"Record success rate"}),"\n",(0,s.jsx)(n.li,{children:"Extract failure modes (finger slip, overrotation, miss)"}),"\n"]}),"\n"]}),"\n"]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Success Metrics (2025 Benchmarks):"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Target"}),": 75\u201380% real-world success (industry standard)"]}),"\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Stretch"}),": 80\u201385% (competitive)"]}),"\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Excellence"}),": >85% (research-grade)"]}),"\n"]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Hints:"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check Tesla Optimus gripper specs: 100 N max force, 20 mm travel"}),"\n",(0,s.jsx)(n.li,{children:"Use force/torque sensor data to debug failures"}),"\n",(0,s.jsx)(n.li,{children:"Friction randomization is the highest-impact parameter"}),"\n"]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"47-references",children:"4.7 References"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Sim-to-Real Transfer:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'OpenAI, "Domain Randomization for Transferring Deep Neural Networks from Simulation to the Real World," arXiv:1703.06907 (2017).'}),"\n",(0,s.jsx)(n.li,{children:'Tobin et al., "Domain Randomization and Generative Models for Robotic Grasping," arXiv:1810.10995 (2018).'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Gazebo & URDF:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Gazebo Documentation: ",(0,s.jsx)(n.a,{href:"https://gazebosim.org/docs",children:"https://gazebosim.org/docs"})]}),"\n",(0,s.jsxs)(n.li,{children:["URDF Specification: ",(0,s.jsx)(n.a,{href:"http://wiki.ros.org/urdf",children:"http://wiki.ros.org/urdf"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Physics Simulation:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Erleben, K., "Stable Rigid Body Dynamics using Manifold Contact," PhD Thesis, University of Copenhagen (2005).'}),"\n",(0,s.jsxs)(n.li,{children:["Bullet Physics Engine: ",(0,s.jsx)(n.a,{href:"https://github.com/bulletphysics/bullet3",children:"https://github.com/bulletphysics/bullet3"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Domain Randomization at Scale:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Peng et al., "Sim-to-Real Transfer of Robotic Control with Dynamics Randomization," ICRA 2018.'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"48-rag-integration-hooks",children:"4.8 RAG Integration Hooks"}),"\n",(0,s.jsx)(n.p,{children:":::rag-query What is the difference between physics engines (ODE, Bullet, DART)?\nLearn which simulator to choose for your humanoid: ODE (simple, fast), Bullet (stable, accurate), DART (biomechanics-focused).\n:::"}),"\n",(0,s.jsx)(n.p,{children:":::rag-query How do I add custom sensors (custom tactile sensor, pressure mat) to Gazebo?\nExtend Gazebo with plugins to simulate non-standard sensors for specialized humanoid tasks.\n:::"}),"\n",(0,s.jsx)(n.p,{children:":::rag-query What causes the reality gap, and how do I measure it quantitatively?\nDomain randomization strategies and metrics for evaluating sim-to-real transfer success in humanoid manipulation.\n:::"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Concept"}),(0,s.jsx)(n.th,{children:"Key Takeaway"}),(0,s.jsx)(n.th,{children:"Application"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Digital Twin"})}),(0,s.jsx)(n.td,{children:"Virtual replica for safe, fast iteration"}),(0,s.jsx)(n.td,{children:"Train 100k+ episodes without hardware"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"URDF"})}),(0,s.jsx)(n.td,{children:"XML specification of robot structure"}),(0,s.jsx)(n.td,{children:"Load any robot into Gazebo in minutes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Gazebo Physics"})}),(0,s.jsx)(n.td,{children:"Real-time 3D rigid-body simulation"}),(0,s.jsx)(n.td,{children:"Test control algorithms pre-deployment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Sensor Simulation"})}),(0,s.jsx)(n.td,{children:"IMU, camera, F/T with realistic noise"}),(0,s.jsx)(n.td,{children:"Bridge sim-to-real gap via randomization"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Domain Randomization"})}),(0,s.jsx)(n.td,{children:"Train with randomized parameters"}),(0,s.jsx)(n.td,{children:"Deploy with 70\u201380% success rate"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Next Chapter:"})," ",(0,s.jsx)(n.a,{href:"/docs/ch5-vla",children:"Chapter 5: Vision-Language-Action Systems"})," \u2014 Learn how to ground large language models (Llama 3) to humanoid action trajectories."]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var r=i(6540);const s={},a=r.createContext(s);function t(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(a.Provider,{value:n},e.children)}},9365:(e,n,i)=>{i.d(n,{A:()=>t});i(6540);var r=i(4164);const s={tabItem:"tabItem_Ymn6"};var a=i(4848);function t(e){var n=e.children,i=e.hidden,t=e.className;return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,t),hidden:i,children:n})}}}]);